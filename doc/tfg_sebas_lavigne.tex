\documentclass[a4paper,
	11pt,
	parskip=full,
	bibliography=totoc,
	twoside
	]{scrartcl}
	
%Indentation
\parskip=12pt 
\parindent=0pt

%Line spacing
\usepackage{setspace} 

%Language
\usepackage[spanish]{babel}
\renewcommand\spanishtablename{Tabla}

%SI
\usepackage[detect-none]{siunitx}
\sisetup{range-phrase = \text{--}}

%Hyperlinks
\usepackage[
urlcolor=WaveBlue,
citecolor=WaveLightBlue,
linkcolor=WaveLightBlue,
colorlinks=true
]{hyperref}
\newcommand*{\Appendixautorefname}{Apéndice}

%Fonts
\renewcommand*\familydefault{\sfdefault} 
\usepackage[T1]{fontenc}
\usepackage{fontspec}
\usepackage[svgnames]{xcolor}
\usepackage{titlesec}
\defaultfontfeatures{Ligatures=TeX}
%\usepackage[scaled]{helvet}
% Set sans serif font to Calibri
\setsansfont{Arial}
% Set serifed font to Cambria
\setmainfont{Cardo}

%Itemize character
\renewcommand{\labelitemi}{$\bullet$}

%Colors
\definecolor{WaveBlue}{RGB}{0,11,100}
\definecolor{WaveLightBlue}{rgb}{0.32,0.60,0.98}


\addtokomafont{section}{\rmfamily\bfseries\LARGE\color{WaveBlue}}
\addtokomafont{sectioning}{\rmfamily\bfseries\color{WaveBlue}}
\addtokomafont{part}{\rmfamily\bfseries\color{WaveBlue}}
%\titleformat*{\section}{\Large\bfseries\normalfont\color{MSBlue}}
%\titleformat*{\subsection}{\large\bfseries\sffamily\color{MSLightBlue}}
%\titleformat*{\subsubsection}{\large\bfseries\sffamily\color{MSLightBlue}}
%\titleformat*{\paragraph}{\large\bfseries\sffamily\color{MSLightBlue}}
%\titleformat*{\subparagraph}{\large\bfseries\sffamily\color{MSLightBlue}}

%Euro symbol
\usepackage[official]{eurosym}

%Line Spacing
% 1.3 indica "uno y medio"
%\linespread{1.3}

%New page on new section
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}

%No page break in paragraphs
%\widowpenalties 1 10000
%\raggedbottom

%Start section on odd page
\let\oldsection\section
\def\section{\cleardoubleoddpage\oldsection}

%Lines after paragraph and subparagraph
\RedeclareSectionCommands[
afterskip=1sp
]{paragraph,subparagraph}

%Footnotes reset counters per page
\usepackage{perpage} %the perpage package
\MakePerPage{footnote} %the perpage package command

%Lists customization
\usepackage{enumitem}

%Graphics
\usepackage{graphicx}
\usepackage{caption}
\usepackage{sidecap}
\usepackage{float}
\usepackage{wrapfig}

%Charts and plots
%\usepackage{pgf-pie}

%Floating limits
\usepackage{placeins}

%TOC
%\usepackage[toc]{multitoc}
%\renewcommand*{\multicolumntoc}{2}
%\setlength{\columnseprule}{0.5pt}
\usepackage{tocloft}
%\renewcommand{\cftchapfont}{\normalfont\sffamily}   
\renewcommand{\cftsecfont}{\bfseries\sffamily\color{WaveBlue}} 

		%Cambia el espacio entre lineas del indice
		\setlength\cftparskip{4pt}
		%\setlength\cftbeforechapskip{0pt}

%Booktabs style table
\usepackage{booktabs}
\newcommand{\tabitem}{~~\llap{\textbullet}~~}

%Mutlicols
\usepackage{multicol}
\setlength{\columnsep}{1cm}

%Citas
\usepackage[autostyle]{csquotes} 

%Headers and footers
\usepackage{fancyhdr}
\setlength\headheight{15.2pt}
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}
\fancyhf[HLE]{\rmfamily\itshape Java Untersee}
\fancyhf[HRE]{\rmfamily\rightmark}
\fancyhf[HLO]{\includegraphics[height=1cm]{img/IC_iesvallejerteplasencia.png}}
\fancyhf[HRO]{\rmfamily Sebastián Lavigne Kálmar}
\fancyhf[FLE,FRO]{\thepage}
\fancyhf[FC]{}
%\fancyhf[FLE, FLO]{David Bermejo, Sebastián Lavigne}

\addtolength{\textheight}{1.5cm}

%Switch margins for binding
%\let\tmp\oddsidemargin
%\let\oddsidemargin\evensidemargin
%\let\evensidemargin\tmp
%\reversemarginpar

%Included pdfs
\usepackage{pdfpages}

%Title page
%\title{Java Untersee}
%\subtitle{text}

\begin{document}
%\includepdf{cover.pdf}

\cleardoubleoddpage
\begin{titlepage}
	{\space}
	\vspace{5cm}
	\centering
	{\rmfamily\bfseries\Huge Java Untersee\par}
	\vspace{1.5cm}
	{\rmfamily\scshape\LARGE Proyecto de innovación\par}
	\vspace{1.5cm}
	{\rmfamily\scshape\LARGE Grado en Desarrollo de Aplicaciones Multiplataforma \par}
	\vspace{0.2cm}
	{\rmfamily\scshape\Huge I.E.S. Valle del Jerte \par}
	\vspace{1cm}
	\raggedleft
	\vfill
	{\rmfamily\bfseries\large 2º DAM\linebreak}
	{\rmfamily\bfseries\large\today\par}
	\vspace{1cm}
	{\rmfamily\bfseries\Large Sebastián Lavigne Kálmar\linebreak}
	{76121350K}
	\vfill
	\includegraphics[width=6cm]{img/DAM_iesvallejerteplasencia.png}
	
	
	
\end{titlepage}

\cleardoubleoddpage
\tableofcontents
%\addtocontents{toc}{\protect\thispagestyle{fancy}}
%\addtocontents{toc}{~\hfill\textbf{Página}\par}

\doublespacing

\cleardoubleoddpage
\section{Descripción}
\label{sec:descripcion}
	\textit{Java Untersee} es una simulación de submarinos desarrollada en \textit{Java} con un motor de juego propio basado en la librería \textit{Swing}.
	
	Toma inspiración de varios juegos de simulación y estrategia, así como de varios conceptos vistos a lo largo del ciclo y en las prácticas de empresa.
	
	Está publicado en la plataforma \textit{GitHub}\footnote{Alojado en el repositorio \href{https://github.com/SebLavK/java-untersee}{https://github.com/SebLavK/java-untersee}} bajo la Licencia Pública General de GNU, \textit{GPLv3}.

\section{Objetivos}
\label{sec:objetivos}
	El proyecto se puede definir como un conjunto de distintos desafíos de programación, siendo cada uno un objetivo surgido de forma orgánica durante su desarrollo. El objetivo principal consiste, entonces, en integrar los distintos componentes creados a partir de estos desafíos para presentar un juego con una experiencia única y original.
	
	Para materializar un programa sólido y expansible se tienen en cuenta las siguientes restricciones:
	\begin{itemize}[noitemsep]
		\item Crear componentes avanzados sin recurrir a librerías externas para explorar y comprender diversos conceptos de programación.
		\item Ahondar en las posibles implementaciones de las librerías que sí están presentes para aprovechar su potencial.
		\item Construir el software en siguiendo el patrón de arquitectura \textit{Modelo Vista Controlador}.
		\item Perseguir las buenas costumbres en la estructura y calidad del código.
		\item Mantener el proyecto alojado, licenciado y documentado en la nube de forma pública para servir de referencia e inspiración a otras personas.
		\item Trabajar con la metodología \textit{Git Flow} para el control de versiones.
	\end{itemize}
	
	\textit{Java Untersee}, como juego, no tiene una visión o un estado final definido sino que sirve como aliciente para mejorar y conocer nuevas vías en el mundo del desarrollo de software.

\section{Justificación}
\label{sec:justificacion}
	Este proyecto parte de una tarea del módulo \textit{Desarrollo de Interfaces} cuyo objetivo original era presentar un programa que trabajase con gráficos en tiempo real. Durante su desarrollo comencé a implementar varias características que iban más allá del ámbito de la tarea.
	
	Como se ha visto en los \nameref{sec:objetivos}, estas características presentan desafíos que me impulsaron a descubrir el funcionamiento detrás de procesos informáticos involucrados en tareas como el análisis sintáctico, el renderizado de imágenes o la simulación.
	
	El programa es un cajón de arena en el que probar varias ideas y compartir soluciones con otros programadores. Su estado actual está definido tanto por las características ya implementadas como por conceptos que se han pensado para su futuro. Está destinado con carácter abierto a entusiastas de la programación y la simulación.

\section{Descripción técnica}
\label{sec:desc_tecnica}
	\subsection{Estructura del proyecto}
	\label{subsec:estructura}
		El proyecto está construido siguiendo el patrón de arquitectura \textit{Modelo Vista Controlador} \cite{tutorialspoint_mvc}.
		
		\paragraph{El modelo}
			Contiene una representación numérica del mundo simulado. Aquí existen los distintos barcos y el submarino del jugador contenidos dentro de un \textit{escenario} que está aislado del resto del programa. Es decir, el modelo no conoce sobre la existencia de la vista, del controlador, o incluso del jugador que influye en su evolución. Como se verá más adelante, existen dentro de él algunas clases que actúan de enlace entre el escenario y el resto del programa. La evolución del modelo a lo largo del tiempo se detalla en la \autoref{subsec:motor_juego} \nameref{subsec:motor_juego}, en la página \pageref{subsec:motor_juego}.
					
		\paragraph{La vista}
			Se encarga de representar gráficamente los datos simulados en el modelo. Se podría decir que la vista sí conoce sobre la existencia del modelo, aunque sólo toma los datos necesarios relativos a la posición de los distintos elementos del juego en cada momento para mostrarlos por pantalla. Su implementación se explica en la \autoref{subsec:motor_grafico} \nameref{subsec:motor_grafico}, en la página \pageref{subsec:motor_grafico}.
			
		\paragraph{El controlador}
			Es el núcleo del programa. Arranca el juego, cargando los datos necesarios e inicializando la vista y el modelo. Su pieza más importante es el \textit{bucle de juego} (definido en la \autoref{subsec:bucle_juego}, página \pageref{subsec:bucle_juego}), que ordena al modelo a avanzar en el tiempo y a la vista a actualizar la información representada. Actúa como puente para la totalidad del programa a través de clases \textit{híbridas}, o intermedias.
			
		\paragraph{Clases híbridas}
			Para facilitar la interacción entre las distintas secciones del programa, existen clases que cumplen funciones que se extienden más allá del ámbito propio de la vista o el modelo. Por ejemplo, la \textit{Cámara} y el \textit{Segundo al mando} están contenidos en el modelo, pero ``son conscientes'' del usuario y contienen información que sólo es relevante a la vista y no a la simulación.  Su uso se explica respectivamente en las subsecciones \ref{subsec:motor_grafico} \nameref{subsec:motor_grafico} (pág. \pageref{subsec:motor_grafico}) y \ref{subsec:interprete_comandos} \nameref{subsec:interprete_comandos} (pág. \pageref{subsec:interprete_comandos}) respectivamente.
			
		\paragraph{Clases comunes}
			En el programa se encuentran algunas clases que son de uso común para todos los componentes. Son la clase utilidad \textit{Magnitudes}, para la conversión de las distintas unidades usadas en la simulación y la representación gráfica; la clase \textit{Reloj}, para cálculos temporales relacionados con el tiempo de ejecución del programa; y la clases \textit{Orden} y \textit{Verbose}, que definen una acción a realizar por el submarino, comandada por el jugador, y su reconocimiento verbal por parte de la tripulación.
			
	\subsection{Bucle de juego}
	\label{subsec:bucle_juego}
		El bucle de juego está contenido en la clase \textit{Máster}, que toma el control del programa una vez se haya arrancado y se hayan cargado sus componentes. Es la fuerza motriz detrás de la simulación y la visualización. \cite{dewitters_game_loop, so_game_loop}
		
		Consiste en un bucle infinito que manda a la vista repintar la pantalla, avanzar temporalmente la simulación y esperar un tiempo determinado antes de la siguiente iteración. Este tiempo de espera varía entre cada iteración dependiendo del tiempo transcurrido en la ejecución de la simulación, que tiende a ser constante, y la representación gráfica, que es mayor o menor en función de los objetos que haya en pantalla.
		
		El bucle busca iterar con una frecuencia de 60 veces por segundo, o cada 16 milisegundos. Cada iteración se guarda la hora del sistema antes y después de las fases de simulación y gráficos, y se calcula el tiempo de espera en base a su diferencia. Esta tasa de refresco está definida en la clase \textit{Reloj} para poder ser ajustada fácilmente.
	
	\subsection{Motor de juego}
	\label{subsec:motor_juego}
		\paragraph{El paso del tiempo}
			Por cada iteración del bucle de juego se ejecuta un paso en la simulación. El motor de juego tiene en cuenta el tiempo que dura cada ``tic'', y por tanto siempre evoluciona igual en tiempo real independientemente de la frecuencia del bucle. Es decir, un barco moviéndose por la pantalla a una velocidad fija siempre recorrerá la misma distancia en el mismo tiempo desde el punto de vista del jugador. Modificar el valor de refresco en la clase \textit{Reloj} sólo alterará la fluidez y la precisión de la simulación.
			
		\paragraph{El escenario}
			La simulación gira en torno a la clase \textit{Escenario}. Ésta contiene el submarino del jugador, una lista de barcos y una lista de proyectiles. Sus funciones consisten en repercutir la orden de avanzar un ``tic'' en todos los objetos del mapa, y eliminarlos si han sido marcados como \textit{destruido}.
		
		\paragraph{La clase Navío}
			La clase abstracta \textit{Navío} es la base de todos los objetos del juego. Contiene las propiedades de posición, dirección y velocidad actual y deseada de un navío, y sus capacidades de aceleración, velocidad máxima y relación de viraje.
			
			También contiene métodos que modifican los valores actuales por cada ``tic'' en función de los valores deseados y capacidades del barco, y métodos de cálculo de posición y dirección relativas a otros objetos.
			
			Cada barco y proyectil del juego heredan de esta clase y definen sus propios atributos, o modifican y añaden sus métodos para definir sus propias habilidades.
			
		\paragraph{Física de los navíos}
			El movimiento de los objetos en el mapa procura ser fiel a la realidad, siguiendo patrones básicos de mecánica clásica y dinámica naval \cite{marine_insight, discover_boating, ships_business}. Esto da al jugador la sensación de estar controlando un navío de gran tamaño, debiendo tener en cuenta el tiempo de respuesta para tomar decisiones por adelantado. Al mismo tiempo, el código procura hacer un balance entre la complejidad del movimiento y la jugabilidad.
			
			Todos los objetos del escenario están contenidos en un espacio bidimensional, con la propiedad adicional de \textit{profundidad}, que está fijada en cero para todos los barcos con la excepción del submarino del jugador. Esto significa que los cálculos de posición relativa siempre están contenidos en el plano, sin tener en cuenta la tercera dimensión que añade la profundidad.
			
			Los cálculos en el motor de juego se realizan con unidades marítimas.
	
	\subsection{Motor gráfico}
	\label{subsec:motor_grafico}
		El proyecto cuenta con un motor gráfico propio para representar la simulación. Usa la librería \textit{Swing} como base para soportar la ventana y los paneles en los que dibujar las imágenes. La vista cuenta con varias clases para representar información en los distintos paneles, siendo la \textit{Pantalla de Mapa} la principal. \cite{techrepublic_java2d, so_resource_stream, so_rendering}
		
		\paragraph{La cámara}
			El objeto \textit{Cámara} es una de las piezas principales en el momento de visualizar el juego por pantalla. Su clase está incluida en el modelo y hereda de \textit{Navío}, por lo que respecto a la simulación es un objeto que se encuentra en el plano junto a los demás barcos. De esta manera puede acceder a los mismos métodos de posición relativa a otros navíos. Posee el atributo propio de zoom, que no es relativo a la simulación pero que es esencial para la vista.
			
			La cámara también admite las acciones del jugador que recibe del controlador. El jugador puede cambiar el nivel de zoom, enfocarse en el submarino o mover la cámara a otros puntos del mapa usando el ratón.
			
		\paragraph{La pantalla de mapa}
			La pantalla de mapa se encarga de representar visualmente la simulación desde un punto de vista cenital. Sitúa la cámara en el centro del panel y dibuja el mar los barcos calculando sus coordenadas en pantalla a partir de la posición relativa en el plano. Para traducir las unidades marítimas que utiliza el juego a píxeles en la pantalla se usa la clase utilidad \textit{Magnitudes}.
			
			En función del zoom que tenga la cámara en cada momento se pinta la pantalla de una forma u otra. Para niveles de zoom cercanos se muestra el juego en una vista ``real'':
			
			\begin{itemize}[noitemsep]
				\item Se rellena el fondo con las casillas del mar animadas. El número y tamaño de casillas a mostrar se calcula en base al zoom de la cámara de forma que ocupen el panel.
				\item Se superpone una imagen con transparencia que simula el brillo del sol en el mar.
				\item Se dibuja el submarino, el resto de barcos y proyectiles presentes en el escenario. El tamaño de su sprite y su posición relativa al centro de la pantalla dependerán del zoom y de su posición relativa a la cámara en la simulación. El submarino cambia a colores más o menos oscuros en función de su profundidad.
			\end{itemize}
		
			Para niveles de zoom lejanos se muestra el juego en una vista ``estratégica'':
			
			\begin{itemize}[noitemsep]
				\item El fondo toma un color fijo y se pintan líneas de cuadrante que representan una distancia de una kiloyarda.
				\item Se marca la posición del submarino y de los barcos con un cuadrado y el nombre con el que hayan sido designados por el sonar en el juego.
				\item Se superpone una imagen con transparencia que simula la pantalla de un viejo monitor.
			\end{itemize}
		
			La cámara tiene definidos los niveles de zoom en los que se pinta el juego de una manera u otra, así como el rango de transición de un modo a otro, en el que se mezclan las dos vistas usando transparencias.
	
	\subsection{Intérprete de comandos}
	\label{subsec:interprete_comandos}
		El intérprete es la pieza central de la interfaz con el jugador. Cuando se introduce un comando por teclado, un parseador lo traduce a una orden que el intérprete puede ejecutar. \cite{codementor_method_reference, freecode_lambda, baeldung_lambda, so_runnable}
		
		\paragraph{El Segundo al mando, parte I}
			El \textit{Segundo al mando} es el intérprete en sí. Es una clase híbrida que forma parte del modelo y que recibe los comandos escritos por el jugador. Su ejecución se realiza fuera del bucle de juego en el hilo de despacho de eventos de \textit{Java AWT} \cite{java_dispatch, baeldung_concurrent} cuando se captura la tecla intro en la consola.
			
			Esta clase contiene métodos de tipo \textit{Consumidor}, es decir, métodos que aceptan un parámetro y no devuelven nada. Este parámetro es una \textit{Orden} de un tipo genérico. El por qué del tipo genérico de hará evidente más adelante, al definir el objeto \textit{Orden} y ver qué hace el \textit{Segundo al mando} con él.
			
			Los métodos consumidores tienen una referencia al submarino del jugador y cada uno contiene instrucciones para alterar sus atributos como, por ejemplo, su velocidad o rumbo deseados.
			
			Al recibir un comando, se pasa al \textit{Parseador} y se pide que genere una \textit{Orden}.
			
		\paragraph{La clase Orden}
			A partir de esta clase se instancian objetos que contienen los datos necesarios para la realización de un cambio por parte del \textit{Segundo al mando}. Es una clase paramétrica, de forma que al crear un nuevo objeto debe establecerse un tipo genérico. Como atributos contiene:
			\begin{labeling}{\textbf{verbose}}
				\item[\textbf{verbo}] Una referencia a un método consumidor de \textit{órdenes del mismo tipo genérico que la clase}.
				\item[\textbf{objeto}] Un objeto \textit{dato} del tipo genérico de la clase.
				\item[\textbf{verbose}] Un objeto \textit{Verbose} con el mensaje que se mostrará al jugador en pantalla. Su funcionamiento se detalla en la \autoref{subsec:propiedades_internacionalizacion} \nameref{subsec:propiedades_internacionalizacion}, en la página \pageref{subsec:propiedades_internacionalizacion}.
			\end{labeling}
		
			
		\paragraph{El Segundo al mando, parte II}
			Cuando el \textit{Segundo al mando} recibe la \textit{Orden}, obtiene de ella la referencia al método consumidor que debe ejecutarse. El consumidor \textit{acepta} la orden como argumento y recorre su código. El objeto \textit{dato} contenido en la orden es la variable que define el comportamiento a seguir por el submarino. Por ejemplo, un doble que establece el nuevo rumbo a tomar.
			
			Al usar tipos genéricos, en el momento de crear una \textit{Orden} se hace obligatorio pasar una referencia a un método que consuma el mismo tipo que la orden. De esta manera, \textit{Java} da un error de compilación si los tipos difieren y se evitan excepciones en tiempo de ejecución. Por ejemplo:
			\begin{quote}
				Al constructor de la \textit{Orden} se pasa una referencia a un consumidor de órdenes tipo entero y un objeto \textit{dato} tipo cadena. Si la clase \textit{Orden} no estuviese parametrizada, el programa compilaría sin errores y el programador no tendría oportunidad de visualizar el fallo hasta que el proceso terminase con una excepción.
			\end{quote}
			
			El hecho de que un método consumidor reciba la misma \textit{Orden} que lo referencia en vez de simplemente recibir el objeto \textit{dato} da más flexibilidad en las acciones que se pueden realizar. Por ejemplo, el método podría modificar el texto a mostrar en pantalla en función del estado del submarino.
			
		\paragraph{El Parseador}
			Es una clase utilidad que recibe una cadena con el comando del jugador, la convierte en una \textit{Orden} y la devuelve al \textit{Segundo al mando} para que la interprete. La \nameref{app:interpreter} se puede consultar en el \autoref{app:interpreter}, en la página \pageref{app:interpreter}.
			
			El \textit{Parseador} contiene un árbol sintáctico, definido usando \textit{mapas de hashes} y referencias a métodos \textit{Runnable}\footnotemark. Estos mapas son constantes y se cargan con el arranque del programa, guardando cadenas como claves y referencias a métodos \textit{Runnables} como sus valores.
			\footnotetext{Es importante destacar que el uso de \textit{Runnable} no implica que se abran nuevos hilos para ejecutar estos métodos. \textit{Runnable} es una interfaz funcional con un método que no recibe parámetros y no retorna nada, por tanto se puede referenciar cualquier otro método que tenga esta misma firma mediante una expresión \textit{lambda} simplificada. \cite{so_runnable}}
			
			Cada nodo del árbol está representado por un método. Los mapas de la clase y los controles de flujo dentro de estos métodos definen las ramificaciones del árbol. Los nodos finales generan una \textit{Orden}, en la mayoría de los casos obteniendo un valor del array para pasarlo en la orden como objeto \textit{dato}.
			
			Antes de comenzar el parseo, como preparación el \textit{Parseador} divide la cadena del comando en un array de palabras.
			
			Como primer paso, se manda al al mapa principal la primera palabra en el array como clave y se obtiene y ejecuta la referencia un método. Los subsecuentes métodos contienen instrucciones propias para procesar el resto de la sentencia. Por ejemplo:
			\begin{quote}
				Dado el comando ``velocidad 5'', primero se pide al mapa principal una referencia con la clave ``velocidad''. El método que devuelve lee la segunda palabra, en este caso ``5'', y crea una nueva \textit{Orden} de tipo doble con una referencia al método \textit{cambiar velocidad}, con el dato 5 y con una respuesta para mostrar por pantalla.
				
				Dado el comando ``motores a un tercio'', se pide al mapa principal una referencia con la clave ``motores''. El método que devuelve esta vez se encarga de obtener una referencia a otro método, ya que para ``motores'' existen varias ramificaciones. Pide al mapa de \textit{parseo de ``motores''} una nueva referencia usando el resto de la cadena como clave. El método final genera una \textit{Orden} igual a la anterior, pero con el dato definido para la opción ``a un tercio''. Otras opciones incluyen, por ejemplo, ``estándar'', ``total'' o ``en flanco''.
			\end{quote}
			

	
	\subsection{Propiedades e internacionalización}
	\label{subsec:propiedades_internacionalizacion}
		Los textos que aparecen en la consola \cite{so_custom_font} como respuesta a los comandos del jugador o eventos del juego llegan a la clase \textit{Panel Lateral} en forma de un objeto tipo \textit{Verbose}, que contiene las claves de los textos a mostrar. El \textit{Panel Lateral} obtiene los textos literales pidiéndolos a un archivo de propiedades usando dichas claves. Así, se puede configurar la internacionalización de los textos en varios idiomas apuntando a distintos archivos de propiedades, donde las claves se mantienen y los literales están traducidos.
		
		Usando esta misma aproximación, en el futuro se podrán configurar los parámetros que definen el funcionamiento de la simulación mediante ficheros de propiedades, en vez de usar codificación fija.
	
\section{Medios utilizados}
\label{sec:medios}
\onehalfspacing
	\subsection{Software}
	\begin{labeling}{\textbf{IntelliJ IDEA}}
		\item[\textbf{Eclipse}] Entorno de desarrollo de \textit{Java}, utilizado en los principios del proyecto.
		\item[\textbf{IntelliJ IDEA}] Otro entorno de desarrollo. El proyecto se migró a este IDE a partir de la versión v0.1.
		\item[\textbf{Sonarlint}] Extensión para IDEs con funciones de análisis de calidad del código.
		\item[\textbf{GIMP}] Manipulador de imágenes, para crear y retocar algunos de los recursos gráficos.
		\item[\textbf{TeXstudio}] Editor de \LaTeX, utilizado para crear estas mismas memorias y otra documentación.
		\item[\textbf{Atom}] Editor de código fuente, usado en la generación de documentos \textit{Markdown} para la documentación en \textit{GitHub}.
		\item[\textbf{Git}] Software de control de versiones distribuidas.
		\item[\textbf{gitflow-avh}] Extensión de \textit{Git} para el modelo de ramas de Vincent Driessen con funciones añadidas.
		\item[\textbf{GitHub}] Servicio de almacenamiento de repositorios en la nube.
		\item[\textbf{exe4j}] Generador de lanzadores para \textit{Windows}.
	\end{labeling}
	
	\subsection{Recursos}
	\label{subsec:recursos}
	El proyecto cuenta con recursos gráficos usados bajo licencias libres o con permiso de los autores.
	
	\paragraph{Sea Warfare set, ships and more}
		Sprites para los distintos barcos y el submarino del jugador.
		\begin{labeling}{\textbf{Dirección}}
			\item[\textbf{Autor}] Lowder2
			\item[\textbf{Licencia}] \href{https://creativecommons.org/publicdomain/zero/1.0/deed.es}{CC0 1.0 Universal (CC0 1.0)
				Dedicación de Dominio Público}
			\item[\textbf{Dirección}] \href{https://opengameart.org/content/sea-warfare-set-ships-and-more}{https://opengameart.org/content/sea-warfare-set-ships-and-more}
		\end{labeling}
	
	\paragraph{The Battle for Wesnoth water animation}
	Sprites para el mar animado y encasillable.
	\begin{labeling}{\textbf{Dirección}}
		\item[\textbf{Autores}] Zabin y zookeper
		\item[\textbf{Licencia}] \href{https://creativecommons.org/publicdomain/zero/1.0/deed.es}{CC0 1.0 Universal (CC0 1.0)
			Dedicación de Dominio Público}
		\item[\textbf{Dirección}] \href{https://opengameart.org/content/the-battle-for-wesnoth-water-animation}{https://opengameart.org/content/the-battle-for-wesnoth-water-animation}
	\end{labeling}

	\paragraph{Joystix Monospace}
	Fuente tipográfica usada en el juego.
	\begin{labeling}{\textbf{Dirección}}
		\item[\textbf{Autores}] Typodermic Fonts
		\item[\textbf{Licencia}] \href{https://www.fontspring.com/lic/jcefupvyrh}{The Fontspring Desktop Font EULA Version 1.7.0 - February 26, 2017} 
		\item[\textbf{Licencia}] \href{https://www.fontspring.com/lic/avhl0opgxj}{The Fontspring Application Font EULA Version 1.7.2 - May 14, 2018}. Usada con fines académicos bajo permiso del autor.
		\item[\textbf{Dirección}] \href{https://opengameart.org/content/the-battle-for-wesnoth-water-animation}{https://opengameart.org/content/the-battle-for-wesnoth-water-animation}
	\end{labeling}

	\paragraph{USS Columbus (SSN 762) performing an emergency ballast blow}
	Foto de un submarino mostrada al arrancar el juego.
	\begin{labeling}{\textbf{Dirección}}
		\item[\textbf{Autores}] U.S. Navy photo by Photographer's Mate 2nd Class David C. Duncan
		\item[\textbf{Licencia}] \href{https://creativecommons.org/publicdomain/mark/1.0/deed.es_ES}{Etiqueta de Dominio Público 1.0)
			Dedicación de Dominio Público}
		\item[\textbf{Dirección}]\href{https://commons.wikimedia.org/wiki/File:980604-N-7726D-002_Submarine_Emergency_Surfacing_Drill.jpg}{Wikimedia Commons}
	\end{labeling}

	\paragraph{USS Devilfish (SS-292) being sunk as a target by Wahoo (SS-565) at San Francisco, CA.}
	Foto de un barco siendo atacado usada en el póster.
	\begin{labeling}{\textbf{Dirección}}
		\item[\textbf{Autor}] US Navy
		\item[\textbf{Licencia}] \href{https://creativecommons.org/publicdomain/mark/1.0/deed.es_ES}{Etiqueta de Dominio Público 1.0)
			Dedicación de Dominio Público}
		\item[\textbf{Dirección}]\href{https://commons.wikimedia.org/wiki/File:USS_Devilfish_sunk_as_target_1968.jpg}{Wikimedia Commons}
	\end{labeling}

	\paragraph{Vladivostok Submarine S-56 Control room}
	Foto del interior de un submarino usada en el póster.
	\begin{labeling}{\textbf{Dirección}}
		\item[\textbf{Autor}]  	Alexxx1979
		\item[\textbf{Licencia}] \href{https://creativecommons.org/licenses/by-sa/4.0/deed.es}{Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0) )
			Dedicación de Dominio Público}
		\item[\textbf{Dirección}]\href{https://commons.wikimedia.org/wiki/File:Vladivostok_Submarine_S-56_Control_room_P8050518_2475.jpg}{Wikimedia Commons}
	\end{labeling}
\doublespacing

\section{Dificultades}
\label{sec:dificultades}
	\subsection{Rendimiento}
	\label{subsec:rendimiento}
		La mayor carga en el rendimiento del programa es la representación gráfica. La librería \textit{Swing} no está optimizada para el tipo de actualización de gráficos en tiempo real que requiere el proyecto. Como se explicó en la \autoref{subsec:bucle_juego} \nameref{subsec:bucle_juego}, en la página \pageref{subsec:bucle_juego}, el tiempo de repintado varía considerablemente en función de los elementos a pintar.
		
		Además, el pintado de los elementos se hace secuencialmente en la misma pantalla. Es decir, los elementos se van añadiendo uno a uno en el lienzo que ve el jugador. Estas acciones no están sincronizadas con el refresco de la salida de vídeo y da lugar a animaciones menos fluidas.
		
		Una solución a este problema, no implementada aún en el proyecto, consiste en generar una imagen en el trasfondo con la que actualizar la pantalla en una única acción \cite{so_graphics_performance}.

\section{ ... otros ...}

\cleardoubleoddpage
%\addcontentsline{toc}{part}{Referencias}
	\renewcommand{\sectionmark}[1]{}
\begin{thebibliography}{9}
	\raggedright
	\input{bibliography}
\end{thebibliography}
\markright{\appendixname}

\cleardoubleoddpage
\appendix
\addcontentsline{toc}{section}{\Large\appendixname}

\section{Lista de comandos}
\label{app:command_list}
	\input{command_list}
	
\section{Secuencia del intérprete}
\label{app:interpreter}
	\begin{enumerate}[noitemsep]
		\item El jugador escribe un comando en la consola del \textit{Panel Lateral} y pulsa intro.
		\item El controlador captura el evento y manda el texto introducido al \textit{Segundo al mando}.
		\item El \textit{Segundo al mando} pide al \textit{Parseador} traducir el comando.
		\item El \textit{Parseador}:
		\begin{enumerate}[noitemsep]
			\item Divide el texto y genera un array de palabras.
			\item Obtiene un método que ejecutar llamando al mapa principal con la primera palabra del array como clave.
			\item Recorre el árbol sintáctico siguiendo las sucesivas instrucciones de los métodos pasados por referencia.
			\item Llega a un método final, que genera una \textit{Orden} que contiene la referencia a un \textit{Consumidor} del \textit{Segundo al mando} (el \textit{verbo}), el dato relevante al método consumidor y un \textit{Verbose} con la respuesta que se mostrará por pantalla.
			\item Retorna la \textit{Orden} generada al \textit{Segundo al mando}.
		\end{enumerate}
		\item El \textit{Segundo al mando} obtiene la referencia a uno de sus métodos consumidores mediante el \textit{verbo} y manda \textit{aceptar} la orden.
		\item El consumidor recibe la \textit{Orden} como argumento y ejecuta sus instrucciones usando, en la mayoría de las ocasiones, el dato contenido en la orden.
		\item Finalmente, el \textit{Segundo al mando} manda el \textit{Verbose} al \textit{Panel Lateral} para mostrar la respuesta en la consola.
	\end{enumerate}

\section{Registro de versiones}
\label{app:changelog}
\singlespacing
	\begin{multicols}{2}
		\input{changelog}
	\end{multicols}

\end{document}
